import SwiftUI
import TelnyxRTC

/// A SwiftUI view that visualizes audio waveforms using current audio levels.
/// This component provides sharp, realistic audio visualization matching the Android implementation.
/// 
/// Unlike a scrolling timeline, this creates a fixed-width waveform that shows the current
/// audio level distributed across frequency bands, similar to an audio equalizer.
///
/// ## Features
/// - Real-time audio level visualization using current audio data
/// - Fixed-width bars that represent frequency distribution
/// - Sharp, responsive waveform animation
/// - Matches Android AudioWaveform behavior with `weight(1f)` and `Arrangement.SpaceBetween`
///
/// ## Usage
/// ```swift
/// // Using current audio level from CallViewModel
/// AudioWaveformView(
///     audioLevels: [viewModel.currentInboundAudioLevel],
///     barColor: .green,
///     title: "Inbound Audio"
/// )
///
/// // Using current audio level from CallViewModel
/// AudioWaveformView(
///     audioLevels: [viewModel.currentOutboundAudioLevel],
///     barColor: .blue,
///     title: "Outbound Audio"
/// )
/// ```
struct AudioWaveformView: View {
    /// Array of audio levels (0.0 to 1.0) for each bar
    let audioLevels: [Float]
    
    /// Color of the waveform bars
    let barColor: Color
    
    /// Optional title to display above the waveform
    let title: String?
    
    /// Minimum bar height in points
    let minBarHeight: CGFloat
    
    /// Maximum bar height in points
    let maxBarHeight: CGFloat
    
    init(
        audioLevels: [Float],
        barColor: Color = .blue,
        title: String? = nil,
        minBarHeight: CGFloat = 2.0,
        maxBarHeight: CGFloat = 50.0
    ) {
        self.audioLevels = audioLevels
        self.barColor = barColor
        self.title = title
        self.minBarHeight = minBarHeight
        self.maxBarHeight = maxBarHeight
    }
    
    var body: some View {
        VStack(spacing: 4) {
            if let title = title {
                Text(title)
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
            
            HStack(spacing: 0.5) {
                // Generate frequency bands from current audio level (like Android)
                let frequencyBands = generateFrequencyBands(from: audioLevels)
                
                ForEach(0..<frequencyBands.count, id: \.self) { index in
                    let level = frequencyBands[index]
                    let clampedLevel = max(0.0, min(1.0, CGFloat(level)))
                    
                    // Calculate bar height - matching Android behavior
                    let barHeight = clampedLevel > 0 ? 
                        max(minBarHeight, minBarHeight + (clampedLevel * (maxBarHeight - minBarHeight))) : 
                        minBarHeight
                    
                    RoundedRectangle(cornerRadius: 0.5)
                        .fill(clampedLevel > 0.01 ? barColor : barColor.opacity(0.1))
                        .frame(
                            maxWidth: .infinity,
                            height: barHeight
                        )
                        .animation(.easeOut(duration: 0.1), value: barHeight)
                }
            }
            .frame(maxWidth: .infinity, height: maxBarHeight)
            .background(
                RoundedRectangle(cornerRadius: 6)
                    .fill(Color.gray.opacity(0.05))
            )
        }
    }
    
    /// Generates frequency bands from the current audio level array
    /// This creates multiple bars that represent different frequency ranges
    private func generateFrequencyBands(from audioLevels: [Float]) -> [Float] {
        // Get the current audio level (or 0 if empty)
        let currentLevel = audioLevels.last ?? 0.0
        
        // Generate 20 bars representing different frequency bands
        let barCount = 20
        var frequencyBands: [Float] = []
        
        for i in 0..<barCount {
            let normalizedIndex = Float(i) / Float(barCount - 1)
            let frequencyLevel = generateFrequencyLevel(
                currentLevel: currentLevel,
                frequencyIndex: normalizedIndex
            )
            frequencyBands.append(frequencyLevel)
        }
        
        return frequencyBands
    }
    
    /// Generates a frequency level for a specific frequency band
    private func generateFrequencyLevel(currentLevel: Float, frequencyIndex: Float) -> Float {
        guard currentLevel > 0.0 else { return 0.0 }
        
        // Create a natural frequency distribution:
        // - Lower frequencies (left) have more energy
        // - Higher frequencies (right) have less energy
        let lowFreqWeight = 1.0 - (frequencyIndex * 0.6)
        
        // Add some controlled randomness for realistic variation
        let randomVariation = Float.random(in: 0.7...1.3)
        
        // Create the frequency response
        let frequencyResponse = currentLevel * lowFreqWeight * randomVariation
        
        // Apply a threshold for cleaner appearance
        return frequencyResponse > 0.05 ? min(1.0, frequencyResponse) : 0.0
    }
}

/// Preview provider for SwiftUI canvas
struct AudioWaveformView_Previews: PreviewProvider {
    static var previews: some View {
        VStack(spacing: 20) {
            // Ultra-responsive speaking pattern - when you speak, bars bounce immediately
            AudioWaveformView(
                audioLevels: [0.9],
                barColor: .green,
                title: "High Level - Speaking Loudly"
            )
            
            // Medium audio level - normal conversation
            AudioWaveformView(
                audioLevels: [0.5],
                barColor: .blue,
                title: "Medium Level - Normal Speech"
            )
            
            // Low audio level - quiet speaking
            AudioWaveformView(
                audioLevels: [0.2],
                barColor: .orange,
                title: "Low Level - Quiet Speech"
            )
            
            // No audio - silence
            AudioWaveformView(
                audioLevels: [0.0],
                barColor: .gray,
                title: "Silence - No Audio"
            )
        }
        .padding()
        .previewLayout(.sizeThatFits)
    }
}
