<!DOCTYPE html>
<html lang="en">
  <head>
    <title>TelnyxRTC  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
    <script src="js/lunr.min.js" defer></script>
    <script src="js/typeahead.jquery.js" defer></script>
    <script src="js/jazzy.search.js" defer></script>
  </head>
  <body>
    <a title="TelnyxRTC  Reference"></a>
    <header>
      <div class="content-wrapper">
        <p><a href="index.html">TelnyxRTC 2.0.0 Docs</a> (80% documented)</p>
        <div class="header-right">
          <form role="search" action="search.json">
            <input type="text" placeholder="Search documentation" data-typeahead>
          </form>
        </div>
      </div>
    </header>
    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html">TelnyxRTC</a>
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a href="Classes.html">Classes</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Classes/Call.html">Call</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/FileLogger.html">FileLogger</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/MOSCalculator.html">MOSCalculator</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/TxClient.html">TxClient</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/TxDefaultLogger.html">TxDefaultLogger</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Enums.html">Enumerations</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Enums/CallQuality.html">CallQuality</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/CallState.html">CallState</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/CallState/Reason.html">– Reason</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/LogLevel.html">LogLevel</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/PushEnvironment.html">PushEnvironment</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/TxError.html">TxError</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/TxError/SocketFailureReason.html">– SocketFailureReason</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/TxError/ClientConfigurationFailureReason.html">– ClientConfigurationFailureReason</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/TxError/CallFailureReason.html">– CallFailureReason</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/TxError/ServerErrorReason.html">– ServerErrorReason</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/WebRTCEnvironment.html">WebRTCEnvironment</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Protocols.html">Protocols</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Protocols/TxClientDelegate.html">TxClientDelegate</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/TxLogger.html">TxLogger</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Structs.html">Structures</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Structs/CallQualityMetrics.html">CallQualityMetrics</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/CallTerminationReason.html">CallTerminationReason</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/TxCallInfo.html">TxCallInfo</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/TxConfig.html">TxConfig</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/TxPushConfig.html">TxPushConfig</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/TxPushIPConfig.html">TxPushIPConfig</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/TxServerConfiguration.html">TxServerConfiguration</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">
        <section>
          <section class="section">
            
            <h1 id='telnyx-webrtc-ios' class='heading'>telnyx-webrtc-ios</h1>

<p>Enable Telnyx real-time communication services on iOS. :telephone_receiver: :fire:</p>
<h2 id='table-of-contents' class='heading'>Table of Contents</h2>

<ul>
<li><a href="#project-structure">Project Structure</a></li>
<li><a href="#project-setup">Project Setup</a></li>
<li><a href="#sip-credentials">SIP Credentials</a></li>
<li><a href="#adding-telnyx-sdk-to-your-ios-client-application">Adding Telnyx SDK to your iOS Client Application</a></li>
<li><a href="#usage">Usage</a>

<ul>
<li><a href="#telnyx-client-setup">Telnyx Client Setup</a></li>
<li><a href="#telnyx-client-delegate">Telnyx Client Delegate</a></li>
<li><a href="#calls">Calls</a></li>
</ul></li>
<li><a href="#webrtc-statistics">WebRTC Statistics</a>

<ul>
<li><a href="#enabling-webrtc-statistics">Enabling WebRTC Statistics</a></li>
<li><a href="#understanding-webrtc-statistics">Understanding WebRTC Statistics</a></li>
<li><a href="#real-time-call-quality-monitoring">Real-time Call Quality Monitoring</a></li>
<li><a href="#important-notes">Important Notes</a></li>
</ul></li>
<li><a href="#custom-logging">Custom Logging</a></li>
<li><a href="#push-notifications-setup">Push Notifications Setup</a></li>
</ul>
<h2 id='project-structure' class='heading'>Project Structure</h2>

<ul>
<li>SDK project: Enable Telnyx WebRTC communications.</li>
<li>SDK Tests project.</li>
<li>Demo app project.</li>
</ul>
<h2 id='project-setup' class='heading'>Project Setup:</h2>

<ol>
<li>Clone the repository</li>
<li>Run the command <code>pod install</code> to install the dependencies inside the project root folder.</li>
<li>Open the Workspace : <code>TelnyxRTC.xcworkspace</code></li>
<li>You will find 3 targets to build: 

<ul>
<li>The SDK</li>
<li>The SDK Tests</li>
<li>The Demo App</li>
</ul></li>
</ol>

<p align="center">
<img width="247" alt="Screen Shot 2021-05-04 at 18 34 45" src="https://user-images.githubusercontent.com/75636882/117073153-e8f9e680-ad07-11eb-9d1f-685397b071a6.png">
</p>

<ol>
<li>Select the target <code>TelnyxRTC (TelnyxRTC Project)</code> to build the SDK
<p align="center">
<img width="243" alt="Screen Shot 2021-05-04 at 18 35 18" src="https://user-images.githubusercontent.com/75636882/117073140-e3040580-ad07-11eb-8ac6-dc99531550e3.png"></li>
</ol>

<p></p></p>

<ol>
<li>Select the target <code>TelnyxRTCTests</code> to run the tests. You will need to long press over the Run button and select <code>Build for testing</code></li>
</ol>

<p align="center">
<img width="153" align="center" alt="Screen Shot 2021-03-03 at 10 04 05" src="https://user-images.githubusercontent.com/75636882/109810077-d4b24400-7c07-11eb-91ec-d81e72ae9069.png">
</p>

<ol>
<li><p>Select target <code>TelnyxWebRTCDemo</code> to run the demo app. The SDK should be manually built in order to get the app running (Step 5)</p></li>
<li><p>Enjoy 😎
</br>
</br></p>

<table>
<tr>
<td>Credentials</td>
 <td>Outbound call</td>
 <td>Incoming call</td>
</tr>
<tr>
<td><img src="https://user-images.githubusercontent.com/75636882/116748486-eaf53a00-a9d5-11eb-9093-968e8f2bde6e.gif" width=270></td>
<td><img src="https://user-images.githubusercontent.com/75636882/116748473-e597ef80-a9d5-11eb-94a3-2a4a044ea4ff.gif" width=270></td>
<td><img src="https://user-images.githubusercontent.com/75636882/116748481-e92b7680-a9d5-11eb-9fb5-6fe4cb10b797.gif" width=270></td>
</tr>
</table></li>
</ol>

<hr>

<p></br></p>
<h2 id='sip-credentials' class='heading'>SIP Credentials</h2>

<p>In order to start making and receiving calls using the TelnyxRTC SDK you will need to get SIP Credentials:</p>

<ol>
<li>Access to <a href="https://portal.telnyx.com/">https://portal.telnyx.com/</a></li>
<li>Sign up for a Telnyx Account.</li>
<li>Create a Credential Connection to configure how you connect your calls.</li>
<li>Create an Outbound Voice Profile to configure your outbound call settings and assign it to your Credential Connection.</li>
</ol>

<p>For more information on how to generate SIP credentials check the <a href="https://developers.telnyx.com/docs/v2/webrtc/quickstart">Telnyx WebRTC quickstart guide</a>. </p>

<p></br></p>
<h2 id='adding-telnyx-sdk-to-your-ios-client-application' class='heading'>Adding Telnyx SDK to your iOS Client Application:</h2>

<p>Currently the iOS SDK is supported using cocoapods. </p>
<h3 id='cocoapods' class='heading'>Cocoapods</h3>

<p>If your xcode project is not using <a href="https://cocoapods.org/">cocoapods</a> yet, you will need to configure it.</p>

<ol>
<li>Open your podfile and add the TelnyxRTC. 
<code>
pod &#39;TelnyxRTC&#39;, &#39;~&gt; 0.1.0&#39;
</code></li>
<li>Install your pods. You can add the flag &ndash;repo-update to ensure your cocoapods has the specs updated.
<code>
pod install --repo-update
</code></li>
<li>Open your .xcworkspace</li>
<li>Import TelnyxRTC at the top level of your class:
<code>
import TelnyxRTC
</code></li>
<li><p>Disable BITCODE (The GoogleWebRTC dependency has BITCODE disabled):  Go to the Build Settings tab of your app target, search for “bitcode” and set it to “NO”</p>

<p align="center">
<img width="743" alt="Screen Shot 2021-05-07 at 17 46 08" src="https://user-images.githubusercontent.com/75636882/117506545-235bc180-af5c-11eb-91eb-00d60f5844fa.png">
</p></li>
<li><p>Enable VoIP and Audio background modes: Go to Signing &amp; Capabilities tab, press the +Capability button and add those background modes:</p>

<p align="center">
<img width="719" alt="Screen Shot 2021-05-07 at 17 46 54" src="https://user-images.githubusercontent.com/75636882/117506607-3ff7f980-af5c-11eb-8df2-2f9170c12baf.png">
</p></li>
<li><p>Go to your Info.plist file and add the “Privacy - Microphone Usage Description” key with a description that your app requires microphone access in order to make VoIP calls. </p>

<p align="center">
<img width="911" alt="Screen Shot 2021-05-07 at 17 48 17" src="https://user-images.githubusercontent.com/75636882/117506706-6d44a780-af5c-11eb-87e2-d6be092474f2.png">
</p></li>
<li><p>You are all set!
</br></p></li>
</ol>
<h3 id='swift-package-manager' class='heading'>Swift Package Manager</h3>

<p>Xcode has a built-in support for Swift package manager. To add a package : </p>

<ol>
<li>Select Files &gt; Add Packages</li>
<li>On the Swift Package Manager Screen, Search for the <a href="https://github.com/team-telnyx/telnyx-webrtc-ios.git">https://github.com/team-telnyx/telnyx-webrtc-ios.git</a> package.</li>
<li>Select the <strong>main brach</strong> and click Add Package</li>
</ol>

<p align="center">
<img width="911" alt="Screen Shot 2021-05-07 at 17 48 17" src="https://github.com/isaacakakpo1/telnyx-webrtc-ios-smp/assets/134492608/39be0ab7-222f-478c-bba9-cb2813bcb81d">
</p>

<p>NB: if Add Package is stuck downloading try File &gt; Packages &gt; Reset Package Caches or Run the command
<code>rm -rf ~/Library/Caches/org.swift.swiftpm/</code>  in terminal</p>

<p>Read more in <a href="https://developer.apple.com/documentation/xcode/adding_package_dependencies_to_your_app">Apple documentation</a></p>

<p><strong>Hint: Use either Cocoapods or Swift Package Manager for Individual Packages to avoid Duplicate binaries</strong></p>
<h2 id='usage' class='heading'>Usage</h2>
<h3 id='telnyx-client-setup' class='heading'>Telnyx client setup</h3>
<pre class="highlight plaintext"><code>// Initialize the client
let telnyxClient = TxClient()

// Register to get SDK events
telnyxClient.delegate = self

// Setup yor connection parameters.

// Set the login credentials and the ringtone/ringback configurations if required.
// Ringtone / ringback tone files are not mandatory.
// You can user your sipUser and password
let txConfigUserAndPassowrd = TxConfig(sipUser: sipUser,
                                       password: password,
                                       pushDeviceToken: "DEVICE_APNS_TOKEN",
                                       ringtone: "incoming_call.mp3",
                                       ringBackTone: "ringback_tone.mp3",
                                       // Force TURN relay to avoid local network access
                                       forceRelayCandidate: true,
                                       //You can choose the appropriate verbosity level of the SDK.
                                       //Logs are disabled by default
                                       logLevel: .all)

// Or use a JWT Telnyx Token to authenticate
let txConfigToken = TxConfig(token: "MY_JWT_TELNYX_TOKEN",
                             pushDeviceToken: "DEVICE_APNS_TOKEN",
                             ringtone: "incoming_call.mp3",
                             ringBackTone: "ringback_tone.mp3",
                             // Force TURN relay to avoid local network access
                             forceRelayCandidate: true,
                             //You can choose the appropriate verbosity level of the SDK. Logs are disabled by default
                             logLevel: .all)

do {
   // Connect and login
   // Use `txConfigUserAndPassowrd` or `txConfigToken`
   try telnyxClient.connect(txConfig: txConfigToken)
} catch let error {
   print("ViewController:: connect Error \(error)")
}

// You can call client.disconnect() when you're done.
Note: you need to release the delegate manually when you are done.

// Disconnecting and Removing listeners.
telnyxClient.disconnect();

// Release the delegate
telnyxClient.delegate = nil

</code></pre>
<h3 id='telnyx-client-delegate' class='heading'>Telnyx client delegate</h3>

<p>You will need to instantiate the client and set the delegate. </p>
<pre class="highlight plaintext"><code>// Initialize the client
let telnyxClient = TxClient()

// Register to get SDK events
telnyxClient.delegate = self
</code></pre>

<p>Then you will receive the following events:</p>
<pre class="highlight plaintext"><code>extension ViewController: TxClientDelegate {

    func onRemoteCallEnded(callId: UUID) {
        // Call has been removed internally.
    }

    func onSocketConnected() {
       // When the client has successfully connected to the Telnyx Backend.
    }

    func onSocketDisconnected() {
       // When the client from the Telnyx backend
    }

    func onClientError(error: Error)  {
        // Something went wrong.
    }

    func onClientReady()  {
       // You can start receiving incoming calls or
       // start making calls once the client was fully initialized.
    }

    func onSessionUpdated(sessionId: String)  {
       // This function will be executed when a sessionId is received.
    }

    func onIncomingCall(call: Call)  {
       // Someone is calling you.
       // This delegate method will be called when the app is in foreground and the Telnyx Client is connected.
    }

    func onPushCall(call: Call) {
       // If you have configured Push Notifications and app is in background or the Telnyx Client is disconnected
       // this delegate method will be called after the push notification is received.
       // Update the current call with the incoming call
       self.currentCall = call 
    }


    // You can update your UI from here based on the call states.
    // Check that the callId is the same as your current call.
    func onCallStateUpdated(callState: CallState, callId: UUID) {
      // handle the new call state
      switch (callState) {
      case .CONNECTING:
          break
      case .RINGING:
          break
      case .NEW:
          break
      case .ACTIVE:
          break
      case .DONE(let reason):
          // The DONE state may include a termination reason with details about why the call ended
          if let reason = reason {
              print("Call ended with reason: \(reason.cause ?? "Unknown")")
              print("SIP code: \(reason.sipCode ?? 0), SIP reason: \(reason.sipReason ?? "None")")
          }
          break
      case .HELD:
          break
      case .RECONNECTING(let reason):
          print("Call reconnecting: \(reason.rawValue)")
          break
      case .DROPPED(let reason):
          print("Call dropped: \(reason.rawValue)")
          break
      }
    }
}
</code></pre>
<h2 id='calls' class='heading'>Calls</h2>
<h3 id='outboud-call' class='heading'>Outboud call</h3>
<pre class="highlight plaintext"><code>   // Create a client instance
   self.telnyxClient = TxClient()

   // Asign the delegate to get SDK events
   self.telnyxClient?.delegate = self

   // Connect the client (Check TxClient class for more info)
   self.telnyxClient?.connect(....)

   // Create the call and start calling
   self.currentCall = try self.telnyxClient?.newCall(callerName: "Caller name",
                                                     callerNumber: "155531234567",
                                                     // Destination is required and can be a phone number or SIP URI
                                                     destinationNumber: "18004377950",
                                                     callId: UUID.init())
</code></pre>

<p>This is a general example: In order to fully support outbound calls you will need to implement CallKit to properly handle audio states. For more information check <code>Audio Session Handling WebRTC + CallKit</code> section.</p>
<h3 id='inbound-call' class='heading'>Inbound call</h3>

<p>How to answer an incoming call:</p>
<pre class="highlight plaintext"><code>//Init your client
func initTelnyxClient() {
   //
   self.telnyxClient = TxClient()

   // Asign the delegate to get SDK events
   self.telnyxClient?.delegate = self

   // Connect the client (Check TxClient class for more info)
   self.telnyxClient?.connect(....)
}

extension ViewController: TxClientDelegate {
    //....
    func onIncomingCall(call: Call) {
        // We are automatically answering any incoming call as an example, but
        // maybe you want to store a reference of the call, and answer the call after a button press.
        self.myCall = call.answer()
    }
}
</code></pre>

<p>This is a general example: In order to fully support inbound calls you will need to implement PushKit + CallKit. For more information check <code>Setting up VoIP push notifications</code> section.</p>

<hr>

<p></br></p>
<h2 id='call-termination-reasons' class='heading'>Call Termination Reasons</h2>

<p>When a call ends, the SDK provides detailed information about why the call was terminated through the <code><a href="Structs/CallTerminationReason.html">CallTerminationReason</a></code> structure. This information is available in the <code>DONE</code> state of the call.</p>
<h3 id='callterminationreason-structure' class='heading'>CallTerminationReason Structure</h3>

<p>The <code><a href="Structs/CallTerminationReason.html">CallTerminationReason</a></code> structure contains the following fields:</p>

<ul>
<li><code>cause</code>: A string describing the general cause of the call termination (e.g., &ldquo;CALL_REJECTED&rdquo;, &ldquo;USER_BUSY&rdquo;)</li>
<li><code>causeCode</code>: A numerical code corresponding to the cause</li>
<li><code>sipCode</code>: The SIP response code (e.g., 403, 404)</li>
<li><code>sipReason</code>: The SIP reason phrase (e.g., &ldquo;Dialed number is not included in whitelisted countries&rdquo;)</li>
</ul>
<h3 id='accessing-call-termination-reasons' class='heading'>Accessing Call Termination Reasons</h3>

<p>You can access the termination reason in the <code>onCallStateUpdated</code> delegate method:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">onCallStateUpdated</span><span class="p">(</span><span class="nv">callState</span><span class="p">:</span> <span class="kt">CallState</span><span class="p">,</span> <span class="nv">callId</span><span class="p">:</span> <span class="kt">UUID</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">callState</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">.</span><span class="kt">DONE</span><span class="p">(</span><span class="k">let</span> <span class="nv">reason</span><span class="p">):</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">reason</span> <span class="o">=</span> <span class="n">reason</span> <span class="p">{</span>
            <span class="c1">// Access termination details</span>
            <span class="k">let</span> <span class="nv">cause</span> <span class="o">=</span> <span class="n">reason</span><span class="o">.</span><span class="n">cause</span>
            <span class="k">let</span> <span class="nv">sipCode</span> <span class="o">=</span> <span class="n">reason</span><span class="o">.</span><span class="n">sipCode</span>
            <span class="k">let</span> <span class="nv">sipReason</span> <span class="o">=</span> <span class="n">reason</span><span class="o">.</span><span class="n">sipReason</span>

            <span class="c1">// Display or log the information</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Call ended: </span><span class="se">\(</span><span class="n">cause</span> <span class="p">??</span> <span class="s">"Unknown"</span><span class="se">)</span><span class="s">, SIP: </span><span class="se">\(</span><span class="n">sipCode</span> <span class="p">??</span> <span class="mi">0</span><span class="se">)</span><span class="s"> </span><span class="se">\(</span><span class="n">sipReason</span> <span class="p">??</span> <span class="s">""</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">break</span>
    <span class="c1">// Handle other states...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h3 id='common-termination-causes' class='heading'>Common Termination Causes</h3>

<p>The SDK provides various termination causes, including:</p>

<ul>
<li><code>NORMAL_CLEARING</code>: Call ended normally</li>
<li><code>USER_BUSY</code>: The called party is busy</li>
<li><code>CALL_REJECTED</code>: The call was rejected</li>
<li><code>UNALLOCATED_NUMBER</code>: The dialed number is invalid</li>
<li><code>INCOMPATIBLE_DESTINATION</code>: The destination cannot handle the call type</li>
</ul>
<h2 id='webrtc-statistics' class='heading'>WebRTC Statistics</h2>

<p>The SDK provides WebRTC statistics functionality to assist with troubleshooting and monitoring call quality. This feature is controlled through the <code>debug</code> flag in the <code><a href="Classes/TxClient.html">TxClient</a></code> configuration.</p>
<h3 id='enabling-webrtc-statistics' class='heading'>Enabling WebRTC Statistics</h3>

<p>To enable WebRTC statistics logging:</p>
<pre class="highlight plaintext"><code>let txConfig = TxConfig(sipUser: sipUser,
                       password: password,
                       pushDeviceToken: "DEVICE_APNS_TOKEN",
                       debug: true) // Enable WebRTC statistics
</code></pre>
<h3 id='understanding-webrtc-statistics' class='heading'>Understanding WebRTC Statistics</h3>

<p>When <code>debug: true</code> is configured:</p>

<ul>
<li>WebRTC statistics logs are automatically collected during calls</li>
<li>Logs are sent to the Telnyx portal and are accessible in the Object Storage section</li>
<li>Statistics are linked to the SIP credential used for testing</li>
<li>The logs help the Telnyx support team diagnose issues and optimize call quality</li>
</ul>
<h3 id='real-time-call-quality-monitoring' class='heading'>Real-time Call Quality Monitoring</h3>

<p>The SDK provides real-time call quality metrics through the <code>onCallQualityChange</code> callback on the <code><a href="Classes/Call.html">Call</a></code> object. This allows you to monitor call quality in real-time and provide feedback to users.</p>
<h4 id='using-oncallqualitychanged' class='heading'>Using onCallQualityChanged</h4>
<pre class="highlight plaintext"><code>// When creating a new call set debug to true for CallQualityMetrics
let call = try telnyxClient.newCall(callerName: "Caller name",
                                   callerNumber: "155531234567",
                                   destinationNumber: "18004377950",
                                   callId: UUID.init(),debug:true)

//When accepting a call
telnyxClient?.answerFromCallkit(answerAction: action,debug:true) or call?.answer(debug:true)

// Set the onCallQualityChange callback
call.onCallQualityChange = { metrics in
    // Handle call quality metrics
    print("Call quality: \(metrics.quality.rawValue)")
    print("MOS score: \(metrics.mos)")
    print("Jitter: \(metrics.jitter * 1000) ms")
    print("Round-trip time: \(metrics.rtt * 1000) ms")

    // Update UI based on call quality
    switch metrics.quality {
    case .excellent, .good:
        // Show excellent/good quality indicator
        self.qualityIndicator.backgroundColor = .green
    case .fair:
        // Show fair quality indicator
        self.qualityIndicator.backgroundColor = .yellow
    case .poor, .bad:
        // Show poor/bad quality indicator
        self.qualityIndicator.backgroundColor = .red
        // Optionally show a message to the user
    case .unknown:
        // Quality couldn't be determined
        self.qualityIndicator.backgroundColor = .gray
    }
}
</code></pre>
<h4 id='callqualitymetrics-properties' class='heading'>CallQualityMetrics Properties</h4>

<p>The <code><a href="Structs/CallQualityMetrics.html">CallQualityMetrics</a></code> object provides the following properties:</p>

<table><thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td><code>jitter</code></td>
<td>Double</td>
<td>Jitter in seconds (multiply by 1000 for milliseconds)</td>
</tr>
<tr>
<td><code>rtt</code></td>
<td>Double</td>
<td>Round-trip time in seconds (multiply by 1000 for milliseconds)</td>
</tr>
<tr>
<td><code>mos</code></td>
<td>Double</td>
<td>Mean Opinion Score (1.0-5.0)</td>
</tr>
<tr>
<td><code>quality</code></td>
<td>CallQuality</td>
<td>Call quality rating based on MOS</td>
</tr>
<tr>
<td><code>inboundAudio</code></td>
<td>[String: Any]?</td>
<td>Inbound audio statistics</td>
</tr>
<tr>
<td><code>outboundAudio</code></td>
<td>[String: Any]?</td>
<td>Outbound audio statistics</td>
</tr>
<tr>
<td><code>remoteInboundAudio</code></td>
<td>[String: Any]?</td>
<td>Remote inbound audio statistics</td>
</tr>
<tr>
<td><code>remoteOutboundAudio</code></td>
<td>[String: Any]?</td>
<td>Remote outbound audio statistics</td>
</tr>
</tbody></table>
<h4 id='callquality-enum' class='heading'>CallQuality Enum</h4>

<p>The <code><a href="Enums/CallQuality.html">CallQuality</a></code> enum provides the following values:</p>

<table><thead>
<tr>
<th>Value</th>
<th>MOS Range</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td><code>.excellent</code></td>
<td>MOS &gt; 4.2</td>
<td>Excellent call quality</td>
</tr>
<tr>
<td><code>.good</code></td>
<td>4.1 &lt;= MOS &lt;= 4.2</td>
<td>Good call quality</td>
</tr>
<tr>
<td><code>.fair</code></td>
<td>3.7 &lt;= MOS &lt;= 4.0</td>
<td>Fair call quality</td>
</tr>
<tr>
<td><code>.poor</code></td>
<td>3.1 &lt;= MOS &lt;= 3.6</td>
<td>Poor call quality</td>
</tr>
<tr>
<td><code>.bad</code></td>
<td>MOS &lt;= 3.0</td>
<td>Bad call quality</td>
</tr>
<tr>
<td><code>.unknown</code></td>
<td>N/A</td>
<td>Unable to calculate quality</td>
</tr>
</tbody></table>
<h4 id='best-practices-for-call-quality-monitoring' class='heading'>Best Practices for Call Quality Monitoring</h4>

<ol>
<li><p><strong>User Feedback</strong>: </p>

<ul>
<li>Consider showing a visual indicator of call quality to users</li>
<li>For poor quality calls, provide suggestions (e.g., &ldquo;Try moving to an area with better connectivity&rdquo;)</li>
</ul></li>
<li><p><strong>Logging</strong>:</p>

<ul>
<li>Log quality metrics for later analysis</li>
<li>Track quality trends over time to identify patterns</li>
</ul></li>
<li><p><strong>Adaptive Behavior</strong>:</p>

<ul>
<li>Implement adaptive behaviors based on call quality</li>
<li>For example, suggest switching to audio-only if video quality is poor</li>
</ul></li>
<li><p><strong>Performance Considerations</strong>:</p>

<ul>
<li>The callback is triggered periodically (approximately every 2 seconds)</li>
</ul></li>
</ol>
<h3 id='important-notes' class='heading'>Important Notes</h3>

<ol>
<li><p><strong>Log Access</strong>: </p>

<ul>
<li>If you run the app using SIP credential A with <code>debug: true</code>, the WebRTC logs will be available in the Telnyx portal account associated with credential A</li>
<li>Logs are stored in the Object Storage section of your Telnyx portal</li>
</ul></li>
<li><p><strong>Troubleshooting Support</strong>:</p>

<ul>
<li>WebRTC statistics are primarily intended to assist the Telnyx support team</li>
<li>When requesting support, enable <code>debug: true</code> in <code><a href="Classes/TxClient.html">TxClient</a></code> for all instances</li>
<li>Provide the <code>debug ID</code> or <code>callId</code> when contacting support</li>
<li>Statistics logging is disabled by default to optimize performance</li>
</ul></li>
<li><p><strong>Best Practices</strong>:</p>

<ul>
<li>Enable <code>debug: true</code> only when troubleshooting is needed</li>
<li>Remember to provide the <code>debug ID</code> or <code>callId</code> in support requests</li>
<li>Consider disabling debug mode in production unless actively investigating issues</li>
</ul></li>
</ol>

<hr>

<p></br></p>
<h2 id='custom-logging' class='heading'>Custom Logging</h2>

<p>The SDK provides a flexible logging system that allows you to implement your own custom logger. This feature enables you to route SDK logs to your preferred logging framework or format.</p>
<h3 id='implementing-a-custom-logger' class='heading'>Implementing a Custom Logger</h3>

<p>To create a custom logger, implement the <code><a href="Protocols/TxLogger.html">TxLogger</a></code> protocol:</p>
<pre class="highlight plaintext"><code>class MyCustomLogger: TxLogger {
    func log(level: LogLevel, message: String) {
        // Implement your custom logging logic here
        // Example: Send logs to your analytics service
        MyAnalyticsService.log(
            level: level,
            message: message,
        )
    }
}
</code></pre>
<h3 id='using-a-custom-logger' class='heading'>Using a Custom Logger</h3>

<p>To use your custom logger, pass it to the <code><a href="Structs/TxConfig.html">TxConfig</a></code> when initializing the client:</p>
<pre class="highlight plaintext"><code>let customLogger = MyCustomLogger()
let txConfig = TxConfig(
    sipUser: sipUser,
    password: password,
    logLevel: .all,           // Set desired log level
    customLogger: customLogger // Pass your custom logger
)
</code></pre>
<h3 id='default-logger' class='heading'>Default Logger</h3>

<p>If no custom logger is provided, the SDK uses <code><a href="Classes/TxDefaultLogger.html">TxDefaultLogger</a></code> which prints logs to the console with appropriate formatting and emojis for different log levels.</p>
<h3 id='important-notes' class='heading'>Important Notes</h3>

<ol>
<li><p><strong>Log Levels</strong>: </p>

<ul>
<li>The <code>logLevel</code> parameter in <code><a href="Structs/TxConfig.html">TxConfig</a></code> still controls which logs are processed</li>
<li>Custom loggers only receive logs that match the configured verbosity level</li>
</ul></li>
<li><p><strong>Thread Safety</strong>:</p>

<ul>
<li>Ensure your custom logger implementation is thread-safe</li>
<li>Log callbacks may come from different threads</li>
</ul></li>
<li><p><strong>Performance</strong>:</p>

<ul>
<li>Keep logging operations lightweight to avoid impacting call quality</li>
<li>Consider asynchronous logging for heavy operations</li>
</ul></li>
<li><p><strong>Best Practices</strong>:</p>

<ul>
<li>Handle all log levels appropriately</li>
<li>Include timestamps for proper log sequencing</li>
<li>Consider log persistence for debugging</li>
<li>Handle errors gracefully within the logger</li>
</ul></li>
</ol>

<hr>

<p></br></p>
<h2 id='push-notifications-setup' class='heading'>Push Notifications Setup</h2>

<p>In order to receive incoming calls while the app is running in background or closed, you will need to perform a set of configurations over your Mission Control Portal Account and your application. </p>

<p>For detailed documentation on setting up push notifications, see:</p>

<ul>
<li><a href="docs-markdown/push-notification/app-setup.md">App Setup</a> - Configure your iOS app to receive VoIP push notifications</li>
<li><a href="docs-markdown/push-notification/portal-setup.md">Portal Setup</a> - Set up your Telnyx Portal account with VoIP push credentials</li>
</ul>

<p></br></p>
<h3 id='voip-push-portal-setup' class='heading'>VoIP Push - Portal setup</h3>

<p>During this process you will learn how to create a VoIP push credential and assign the credential to a SIP Connection. </p>

<p>This process requires:</p>

<ul>
<li>A Mission Control Portal Account.</li>
<li>A SIP Connection.</li>
<li>Your Apple VoIP push certificate.</li>
</ul>

<p>For complete instructions on how to setup Push Notifications got to this <a href="https://developers.telnyx.com/docs/v2/webrtc/push-notifications">link</a>.</p>

<p></br></p>
<h3 id='voip-push-app-setup' class='heading'>VoIP Push - App Setup</h3>

<p>The following setup is required in your application to receive Telnyx VoIP push notifications:</p>
<h4 id='a-add-push-notifications-capability-to-your-xcode-project' class='heading'>a. Add Push Notifications capability to your Xcode project</h4>

<ol>
<li>Open the xcode workspace associated with your app.</li>
<li>In the Project Navigator (the left-hand menu), select the project icon that represents your mobile app.</li>
<li>In the top-left corner of the right-hand pane in Xcode, select your app&rsquo;s target.</li>
<li><p>Press the  +Capabilities button.</p>

<p align="center">
  <img width="294" alt="Screen Shot 2021-11-26 at 13 34 12" src="https://user-images.githubusercontent.com/75636882/143610180-04e2a98c-bb08-4f06-b81a-9a3a4231d389.png">
</p></li>
<li><p>Enable Push Notifications</p>

<p align="center">
  <img width="269" alt="Screen Shot 2021-11-26 at 13 35 51" src="https://user-images.githubusercontent.com/75636882/143610372-abab46cc-dd2a-4712-9020-240f9dbaaaf7.png">
</p></li>
</ol>
<h4 id='b-configure-pushkit-into-your-app' class='heading'>b. Configure PushKit into your app:</h4>

<ol>
<li>Import pushkit
<code>Swift
import PushKit
</code></li>
<li>Initialize PushKit: 
&ldquo;`Swift
private var pushRegistry = PKPushRegistry.init(queue: DispatchQueue.main)
&hellip;</li>
</ol>

<p>func initPushKit() {
  pushRegistry.delegate = self
  pushRegistry.desiredPushTypes = Set([.voIP])
}</p>
<pre class="highlight plaintext"><code>3. Implement PKPushRegistryDelegate 
```Swift
extension AppDelegate: PKPushRegistryDelegate {

    // New push notification token assigned by APNS.
    func pushRegistry(_ registry: PKPushRegistry, didUpdate credentials: PKPushCredentials, for type: PKPushType) {
        if (type == .voIP) {
            // This push notification token has to be sent to Telnyx when connecting the Client.
            let deviceToken = credentials.token.reduce("", {$0 + String(format: "%02X", $1) })
            UserDefaults.standard.savePushToken(pushToken: deviceToken)
        }
    }

    func pushRegistry(_ registry: PKPushRegistry, didInvalidatePushTokenFor type: PKPushType) {
        if (type == .voIP) {
            // Delete incoming token in user defaults
            let userDefaults = UserDefaults.init()
            userDefaults.deletePushToken()
        }
    }

    /**
     This delegate method is available on iOS 11 and above. 
     */
    func pushRegistry(_ registry: PKPushRegistry, didReceiveIncomingPushWith payload: PKPushPayload, for type: PKPushType, completion: @escaping () -&gt; Void) {
        if (payload.type == .voIP) {
            self.handleVoIPPushNotification(payload: payload)
        }

        if let version = Float(UIDevice.current.systemVersion), version &gt;= 13.0 {
            completion()
        }
    }

    func handleVoIPPushNotification(payload: PKPushPayload) {
        if let metadata = payload.dictionaryPayload["metadata"] as? [String: Any] {

            let callId = metadata["call_id"] as? String
            let callerName = (metadata["caller_name"] as? String) ?? ""
            let callerNumber = (metadata["caller_number"] as? String) ?? ""
            let caller = callerName.isEmpty ? (callerNumber.isEmpty ? "Unknown" : callerNumber) : callerName


            let uuid = UUID(uuidString: callId)

            // Re-connect the client and process the push notification when is received.
            // You will need to use the credentials of the same user that is receiving the call. 
            let txConfig = TxConfig(sipUser: sipUser,
                                password: password,
                                pushDeviceToken: "APNS_PUSH_TOKEN")


            //Call processVoIPNotification method 

            try telnyxClient?.processVoIPNotification(txConfig: txConfig, serverConfiguration: serverConfig,pushMetaData: metadata)



            // Report the incoming call to CallKit framework.
            let callHandle = CXHandle(type: .generic, value: from)
            let callUpdate = CXCallUpdate()
            callUpdate.remoteHandle = callHandle
            callUpdate.hasVideo = false

            provider.reportNewIncomingCall(with: uuid, update: callUpdate) { error in
                  if let error = error {
                      print("AppDelegate:: Failed to report incoming call: \(error.localizedDescription).")
                  } else {
                      print("AppDelegate:: Incoming call successfully reported.")
                  }
            }
    }
}
</code></pre>

<ol>
<li>If everything is correctly set-up when the app runs APNS should assign a Push Token.</li>
<li>In order to receive VoIP push notifications. You will need to send your push token when connecting to the Telnyx Client.</li>
</ol>
<pre class="highlight plaintext"><code>
 let txConfig = TxConfig(sipUser: sipUser,
                         password: password,
                         pushDeviceToken: "DEVICE_APNS_TOKEN",
                         //You can choose the appropriate verbosity level of the SDK. 
                         logLevel: .all)

 // Or use a JWT Telnyx Token to authenticate
 let txConfigToken = TxConfig(token: "MY_JWT_TELNYX_TOKEN",
                             pushDeviceToken: "DEVICE_APNS_TOKEN",
                             //You can choose the appropriate verbosity level of the SDK. Logs are disabled by default
                             logLevel: .all)
</code></pre>

<p>For more information about Pushkit you can check the official <a href="https://developer.apple.com/documentation/pushkit%5D">Apple docs</a>. </p>

<p><strong><em>Important</em></strong>:</p>

<ul>
<li>You will need to login at least once to send your device token to Telnyx before start getting Push notifications.</li>
<li>You will need to provide <code>pushMetaData</code> to <code>processVoIPNotification()</code> to get Push calls to work.</li>
<li>You will need to implement &lsquo;CallKit&rsquo; to report an incoming call when there’s a VoIP push notification. On iOS 13.0 and later, if you fail to report a call to CallKit, the system will terminate your app. More information on <a href="https://developer.apple.com/documentation/pushkit/pkpushregistrydelegate/2875784-pushregistry">Apple docs</a></li>
</ul>
<h4 id='c-configure-callkit-into-your-app' class='heading'>c. Configure CallKit into your App:</h4>

<p><code>PushKit</code> requires you to use <code>CallKit</code> when handling VoIP calls. <code>CallKit</code> ensures that apps providing call-related services on a user’s device work seamlessly together on the user&rsquo;s device, and respect features like Do Not Disturb. <code>CallKit</code> also operates the system&rsquo;s call-related UIs, including the incoming or outgoing call screens. Use <code>CallKit</code> to present these interfaces and manage interactions with them.</p>

<p>For more information about <code>CallKit</code> you can check the official <a href="https://developer.apple.com/documentation/callkit%5D">Apple docs</a>. </p>

<p><strong><em>General Setup:</em></strong></p>

<ol>
<li>Import CallKit:
<code>Swift
import CallKit
</code></li>
<li><p>Initialize CallKit</p>
<pre class="highlight plaintext"><code>func initCallKit() {
let configuration = CXProviderConfiguration(localizedName: "TelnyxRTC")
configuration.maximumCallGroups = 1
configuration.maximumCallsPerCallGroup = 1
callKitProvider = CXProvider(configuration: configuration)
if let provider = callKitProvider {
  provider.setDelegate(self, queue: nil)
}
}
</code></pre></li>
<li><p>Implement <code>CXProviderDelegate</code> methods.</p></li>
</ol>

<p><strong><em>Audio Session Handling WebRTC + CallKit</em></strong>  </p>

<p>To get <code>CallKit</code> properly working with the <code>TelnyxRTC SDK</code> you need to set the audio device state based on the <code>CallKit</code> AudioSession state like follows:</p>
<pre class="highlight plaintext"><code>extension AppDelegate : CXProviderDelegate {

    ...

    func provider(_ provider: CXProvider, didActivate audioSession: AVAudioSession) {
        self.telnyxClient?.enableAudioSession(audioSession: audioSession)
    }

    func provider(_ provider: CXProvider, didDeactivate audioSession: AVAudioSession) {
        self.telnyxClient?.disableAudioSession(audioSession: audioSession)
    }
}
</code></pre>

<p></br></p>

<p><strong><em>Reporting calls with CallKit</em></strong></p>

<p>To properly report calls to callKit with right statuses, you need to invoke the following callKit methods at the right instances: </p>

<ol>
<li>Starting A New Call : When ever you start a call, report to callkit using the <code>provider.reportCall()</code> method.</li>
</ol>
<pre class="highlight plaintext"><code>        let callUpdate = CXCallUpdate()

        callUpdate.remoteHandle = callHandle
        callUpdate.supportsDTMF = true
        callUpdate.supportsHolding = true
        callUpdate.supportsGrouping = false
        callUpdate.supportsUngrouping = false
        callUpdate.hasVideo = false
        provider.reportCall(with: uuid, updated: callUpdate)
</code></pre>

<ol>
<li>When user receives a Call : Use <code>provider.reportNewIncomingCall(with: uuid, update: callUpdate)</code> to report an incoming call. This sends a request to callKit the to provide the native call interface to the user.</li>
</ol>
<pre class="highlight plaintext"><code>        guard let provider = callKitProvider else {
            print("AppDelegate:: CallKit provider not available")
            return
        }

        let callHandle = CXHandle(type: .generic, value: from)
        let callUpdate = CXCallUpdate()
        callUpdate.remoteHandle = callHandle

        provider.reportNewIncomingCall(with: uuid, update: callUpdate) { error in
            // handle error
        }
</code></pre>

<ol>
<li>When callee answers an outgoing call : Use <code>provider.reportOutgoingCall(with: callKitUUID, connectedAt:nil)</code> to report a connected outgoing call. This provides the time when the outgoing call goes to active to callKit.
<code>Swift
    if let provider = self.callKitProvider,
        let callKitUUID = self.callKitUUID {
        let date = Date()
        provider.reportOutgoingCall(with: callKitUUID, connectedAt:date)
    }
</code>
NB : This should be used only when the call is outgoing.</li>
</ol>
<h3 id='best-practices-when-using-pushnotifications-with-callkit' class='heading'>Best Practices when Using PushNotifications with Callkit.</h3>

<ol>
<li>When receiving calls from push notifications, it is always required to wait for the connection to the WebSocket before fulfilling the call answer action. This can be achieved by implementing the CXProviderDelegate in the following way (SDK version &gt;=0.1.11):
<code>Swift
func provider(_ provider: CXProvider, perform action: CXAnswerCallAction) {
    self.telnyxClient?.answerFromCallkit(answerAction: action)
}
</code></li>
</ol>

<p>When the <code>answerFromPush(answerAction: action)</code> is called, Callkit sets the call state to <code>connecting</code> to alert the user that the call is being connected. 
Once the call is active, the timer starts.</p>

<table align="center">
        <tr>
           <td>Connecting State</td>
           <td>Active call</td>
        </tr>
        <tr>
          <td><img src="https://github.com/team-telnyx/telnyx-webrtc-ios/assets/134492608/13e9efd0-07e2-4a7e-9e7a-b2484b96be47" width=270></td>
          <td><img src="https://github.com/team-telnyx/telnyx-webrtc-ios/assets/134492608/89d506a5-bf97-42f2-bd64-5aa54b202db8" width=270></td>
        </tr>
</table>
   

<p>The previous SDK versions requires handling the websocket connection state on the client side. It can be done in the following way:</p>
<pre class="highlight plaintext"><code>var callAnswerPendingFromPush:Bool = false

func provider(_ provider: CXProvider, perform action: CXAnswerCallAction) {
        print("AppDelegate:: ANSWER call action: callKitUUID [\(String(describing: self.callKitUUID))] action [\(action.callUUID)]")
        if(currentCall != nil){
            self.currentCall?.answer()
        }else {
            self.callAnswerPendingFromPush = true
        }
        action.fulfill()
}

func onPushCall(call: Call) {
        print("AppDelegate:: TxClientDelegate onPushCall() \(call)")
        self.currentCall = call //Update the current call with the incoming call

        //Answer Call if call was answered from callkit
        //This happens when there's a race condition between login and receiving PN
        // when User answer's the call from PN and there's no Call or INVITE message yet. Set callAnswerPendingFromPush = true
        // Whilst we wait fot onPushCall Method to be called
         if(self.callAnswerPendingFromPush){
            self.currentCall?.answer()
            self.callAnswerPendingFromPush = false
        }

}
</code></pre>

<p>Likewise for ending calls, the  <code>endCallFromCallkit(endAction:action)</code> method should be called from :</p>
<pre class="highlight plaintext"><code>func provider(_ provider: CXProvider, perform action: CXEndCallAction) {

        self.telnyxClient?.endCallFromCallkit(endAction:action)

}
</code></pre>

<p>Calling this method solves the race condition, where call is ended before the client connects to the webserver. This way the call is
   ended on the callee side once a connection is established.</p>

<ol>
<li>Logs on the receiver&rsquo;s end are essential for thorough debugging of issues related to push notifications. However, the debugger is not attached when the app is completely killed. To address this, you can simply put the app in the background. VOIP push notifications should then come through, and the debugger should capture all logs.</li>
</ol>

<p><strong><em>Handling Multiple Calls</em></strong></p>

<p>To handle multiples, we can rely on the <code>CXProviderDelegate</code> delegate which invokes functions corresponding to 
what action was performed on the callkit user interface. </p>

<ol>
<li>End and Accept or Decline : The <strong>end and accept</strong> button on the callkit user interface accepts the new call and ends the previous call.
Callkit then invokes the <code>CXAnswerCallAction</code> and <code>CXEndCallAction</code> when the <strong>end and accept</strong> button is pressed.
You can handle this scenario by</li>
</ol>
<pre class="highlight plaintext"><code> var currentCall: Call?
 var previousCall: Call?

 //current calkit uuid
 var callKitUUID: UUID?

     func onIncomingCall(call: Call) {
        guard let callId = call.callInfo?.callId else {
            print("AppDelegate:: TxClientDelegate onIncomingCall() Error unknown call UUID")
            return
        }
        print("AppDelegate:: TxClientDelegate onIncomingCall() callKitUUID [\(String(describing: self.callKitUUID))] callId [\(callId)]")

        self.callKitUUID = call.callInfo?.callId

        //Update the previous call with the current call
        self.previousCall = self.currentCall

        //Update the current call with the incoming call
        self.currentCall = call 
        ..
  }

</code></pre>

<p>Subsequently, when the user clicks on the End and Accept or Decline Button, you will need to determine which of these buttons was clicked.
You can do that as follows:</p>
<pre class="highlight plaintext"><code>    //Callkit invokes CXEndCallAction and  CXAnswerCallAction delegate function for accept and answer
    func provider(_ provider: CXProvider, perform action: CXEndCallAction) {
        print("AppDelegate:: END call action: callKitUUID [\(String(describing: self.callKitUUID))] action [\(action.callUUID)]")

        // if the callKitUUID is the same as the one provided by the action
        // callkit expects you to end the current call
        if(self.callKitUUID == action.callUUID){
            if let onGoingCall = self.previousCall {
                self.currentCall = onGoingCall
                self.callKitUUID = onGoingCall.callInfo?.callId
            }
        }else {
            // callkit expects you to end the previous call
            self.callKitUUID = self.currentCall?.callInfo?.callId
        }
        self.telnyxClient?.endCallFromCallkit(endAction:action)
    }
</code></pre>

<p><strong>Note</strong> </p>

<p>While handling multiple calls, you should report the <strong>call end</strong> to callkit properly with the right callUUID. This will keep your  active calls with the callkit
user interface until there are no more active sessions.</p>

<ol>
<li>Hold and Accept or Decline: The <strong>hold and accept</strong> button on the callkit user interface accepts the new call and holds the previous call.
Callkit then invokes the <code>CXSetHeldCallAction</code> when the <strong>hold and accept</strong> button is pressed.</li>
</ol>
<pre class="highlight plaintext"><code> func provider(_ provider: CXProvider, perform action: CXSetHeldCallAction) {
        print("provider:performSetHeldAction:")
        //request to hold previous call, since we have both the current and previous calls
        previousCall?.hold()
        action.fulfill()
 }
</code></pre>

<p>Also, you will need to un-hold the previous call when the current call gets ended on <code>CXEndCallAction</code>.</p>
<pre class="highlight plaintext"><code>
   func provider(_ provider: CXProvider, perform action: CXEndCallAction) {        
        if(previousCall?.callState == .HELD){
            print("AppDelegate:: call held.. unholding call")
            previousCall?.unhold()
        }
        ...
   }
</code></pre>

<p><strong>Note</strong></p>

<p>While handling multiple calls, you should report the <strong>call end</strong> to callkit properly with the right callUUID. This will keep your  active calls with the callkit
user interface until there are no more active sessions.</p>
<h3 id='disable-push-notification' class='heading'>Disable Push Notification</h3>

<p>Push notifications can be disabled for the current user by calling : </p>
<pre class="highlight plaintext"><code>telnyxClient.disablePushNotifications()
</code></pre>

<p>Note : Signing back in, using same credentials will re-enable push notifications.</p>
<h3 id='privacy-manifest' class='heading'>Privacy Manifest</h3>

<p>Support for privacy manifest is added from version 0.1.26</p>
<h3 id='documentation' class='heading'>Documentation:</h3>

<p>For more information you can:</p>

<ol>
<li>Clone the repository</li>
<li>And check the exported documentation in:  <code>docs/index.html</code></li>
</ol>

<hr>

<p>Questions? Comments? Building something rad? <a href="https://joinslack.telnyx.com/">Join our Slack channel</a> and share.</p>
<h2 id='license' class='heading'>License</h2>

<p><a href="./LICENSE"><code>MIT Licence</code></a> © <a href="https://github.com/team-telnyx">Telnyx</a></p>

          </section>
        </section>
        <section id="footer">
          <p>&copy; 2025 <a class="link" href="https://www.telnyx.com/" target="_blank" rel="external noopener">Telnyx LLC</a>. All rights reserved. (Last updated: 2025-05-21)</p>
          <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external noopener">jazzy ♪♫ v0.15.3</a>, a <a class="link" href="https://realm.io" target="_blank" rel="external noopener">Realm</a> project.</p>
        </section>
      </article>
    </div>
  </body>
</html>
